##Контролна работа № 2 по Функционално програмиране
####специалност Компютърни науки, първи поток
####23.01.2015г.

Решенията на задачите се предават по e-mail на адрес:

>fp2014.fmi@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.hs*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като *attachment-и* в *mail-a*. Освен решения на задачите самият *mail* трябва да съдържа име, административна група и факултен номер. 

##Задача 1 - Обратими числа
Ще казваме, че едно число `Х` е обратимо, ако сумата на `Х` с числото `Y`, образувано от същите цифри, но взети в обратен ред, се състои само от нечетни цифри. Ако числото `Y` започва с водеща нула, то считаме, че `Х` не е обратимо.

Да се напише функция `reversibleNumbers :: Int -> [Int]`, която приема като аргумент число `N` и връща списък с всички обратими числа между `1` и `N` (включително).
###Сигнатура:
```haskell
reversibleNumbers :: Int -> [Int]
```

###Примери:
```haskell
reversibleNumbers 20 -> [12,14,16,18]
reversibleNumbers 31 -> [12,14,16,18,21,23,25,27]
reversibleNumbers 10 -> [ ]
```

##Задача 2 - Брой елиминации
Да се напише функция `countEliminations :: [Int] -> Int`, която връща броя на елиминациите, които може да се извършат **една след друга** в даден списък.

Елиминация в списък от числа е процедура, която се осъществява по следния начин:
- намира се **най-голямото число в списъка**;
- ако до него, отляво или отдясно, има същото число, двете числа се премахват от списъка.

Например:
- една елиминация в списъка `[1,2,2,1]` ще върне списъка `[1,1]`
- елиминация в списъка `[10,1,2,3,10,10,2,3]` ще върне `[10,1,2,3,2,3]`
- елиминация в списъка `[1,2,3]` ще върне `[1,2,3]` - същия списък, тъй като няма какво да се елиминира
- елиминация на списъка `[10,10,10.10]` е `[10,10]`
- **елиминация на `[ ]` е `[ ]`, а броят възможни елиминации на `[ ]` е `0`**

Функцията, която трябва да се напише, взема списък и прилага върху него елиминации, една след друга поред, докато не може да бъде приложена елиминация или се стигне до празен списък.

Функцията трябва да върне броя на извършените елиминации, докато се стигне до един от двата случая.

##Примери:
```haskell
countElimination [1,2,2,1] -> 2
countElimination [] -> 0
countElimination [1,2,3] -> 0
countElimination [5, 8, 10, 10, 8, 5] -> 3
countElimination [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10] -> 10
countElimination [10,10,10,10] -> 2
```
##Задача 3 - Числа с малки цифри
Да се напише функция `smallDigits :: Int -> (Int -> Int)`, която получава като аргумент цяло положително число `N` и връща като резултат функция на един аргумент `K`, `1<=K<=9`. При извикване на върнатата като резултат функция да се връща сумата на всички `Х`<sub>i</sub> - такива, че  за всяко `i` от `1` до `N`, `Х`<sub>i</sub> е най-малкият различен от `1` делител на числото `i`, за който е изпълнено, че всички негови цифри са по-малки или равни на `K`.

##Сигнатура:
```haskell
smallDigits:: Int -> (Int -> Int)
```
##Примери:
```haskell
smallDigits 11 -> функция на един аргумент К
smallDigits 11 2 -> 21 -- числата Xi, за които е изпълнено условието, са:
i = 1, X1 - няма такова. Единственият делител на i е 1, а според условието се търсят само делители, различни от 1
i = 2, X2 = 2: единственият делител на i, различен от 1, е 2 и всички негови цифри са по-малки или равни на K = 2
i = 3, X3 - няма такова. Единственият различен от 1 делител на i е 3, а неговите цифри са по-големи от K = 2
i = 4, X4 = 2: делителите на i различни от 1 са 2 и 4, като единственият с цифри по-малки или равни на К = 2 е 2
i = 5, X5 - няма такова. Единственият различен от 1 делител на i е 5, а неговите цифри са по-големи от К = 2
i = 6, X6 = 2: различните от 1 делители на i са 2, 3 и 6, като само 2 е по-малък или равен на К = 2
i = 7, X7 - няма такова.Единственият различен от 1 делител на i е 7, чиито цифри са по-големи от К = 2
i = 8, X8 = 2
i = 9, X9 - няма такова
i = 10, X10 = 2: делителите, различни от 1, са 2, 5 и 10, като най-малкият отговарящ на условието е 2
i = 11, X11 = 11: единственият различен от 1 делител на i е 11, като всички негови цифри са по-малки или равни на К = 2
търсената сума е X1 +X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10 + X11 = 21
smallDigits 36 2 -> 79
smallDigits 2 2 -> 2
smallDigits 513 4 -> 7507
```

##Задача 4 - Алгебрични типове
Дефинирани са следните типове:
```haskell
data Answer = Yes Int | No Int | Unknown
type Test = [Answer]
type Exam = [Test]
```
Типът `Answer` има `3` `value-constructors`, които задават отговора на даден въпрос от тест, заедно с точките, които той носи или отнема.

##Примери:
```haskell
Yes 5
No 5
Unknown
```

Напишете  следните функции:
- `valueOfAnswer :: Answer ->  Int`, която връща точките, които носи даден отговор, като използва следните правила:
    - `Yes n` дава `n` точки;
    - `No n` отнема `n` точки;
    - `Unknown` дава `0` точки;
- `testScore :: Test -> Int` - връща сумата на точките на всички отговори в теста (оценката на теста);
- `averageScore :: Exam -> Double` - връща средния брой точки на всички тестове в изпита. Това е сумата от оценките на всички тестове / броя на тестовете. Използвайте вградената функция `fromIntegral`, за да разделите две числа от тип `Int` и да получите частно от тип `Double`;
- `aboveLimit :: Int -> Exam -> Int` - връща броя на тестовете, които имат общ брой точки, по-голям или равен на даден лимит, който е зададен като първи аргумент;
- `highestScore :: Exam -> Test` - връща теста с най-висок резултат от изпита. Ако има два теста с еднакакъв резултат, връща първия срещнат.

##Примерни данни за тестване:
```haskell
-- testScore -> 5 - 3 + 0 + 2 - 1 + 3 + 2 - 1 + 0 = 7
exampleTest1 :: Test
exampleTest1 = [Yes 5, No 3, Unknown, Yes 2, No 1, Yes 3, Yes 2, No 1, Unknown]
-- testScore -> 10
exampleTest2 :: Test
exampleTest2 = [Yes 5, Yes 5, Yes 5, No 5, Unknown]
--  averageScore -> 8.5
--  highestScore -> exampleTest2
exampleExam :: Exam
exampleExam = [exampleTest1, exampleTest2]
```

##Задача 5 - Дървета
Нека е дефиниран следният тип, представящ двоично дърво:

```haskell
data Tree a = Empty | Node a (Tree a) (Tree a)
```

Едно дърво ще наричаме **пълно**, ако всеки негов връх е или лист (т.е. лявото и дясното му поддървета са `Empty`), или има точно два наследника (т.е. и лявото, и дясното му поддървета не са `Empty`). Да се напише функция `isFull :: Tree a -> Bool`, която проверява дали едно двоично дърво е пълно. 

##Сигнатура:
```haskell
isFull :: Tree a -> Bool
```

##Примери:
```haskell
fullTree = Node 1
		(Node 2
			(Node 3 Empty Empty)
			(Node 4 Empty Empty))
		(Node 5 Empty Empty)
nonFullTree = Node 1
			(Node 2
				(Node 3 Empty Empty)
				(Node 4 Empty Empty))
			Empty
isFull fullTree -> True
isFull nonFullTree -> False
isFull Empty -> False
isFull (Node 5 Empty Empty) -> True
```

##Задача 6 - Валидация на дебитни карти
Номерата на кредитни и дебитни карти се състоят от нечетен брой цифри и най-често се валидират по следния алгоритъм:
- номерът на картата се трансформира по следния начин (при `0`-базирани индекси):
    - цифрите на четни позиции при прочитане на числото от дясно на ляво се запазват;
    - всяка от цифрите, които се намират на нечетна позиция при прочитане на числото от дясно на ляво, се замества със сумата на цифрите на числото, получено чрез удвояване на означаваното от същата цифра число;
- намира се сумата на цифрите на полученото на предишната стъпка число;
- номерът на картата е валиден, ако получената сума се дели на 10.

Например, номерът 7**9**9**2**7**3**9**8**7**1**3 е валиден, тъй като:
- удвоявайки числата, съответни на цифрите на нечетни позиции от последната към първата, получаваме: 1x2=2, 8x2=16, 3x2=6, 2x2=4, 9x2=18;
- при описаното по-горе сумиране получаваме: 7+(1+8) + 9 + 4 + 7 + 6 + 9 + (1+6) + 7 + 2 + 3 = 70 (кратно на 10). 

Да се напише функция `isValid :: Int -> Bool`, която проверява дали даден номер на кредитна / дебитна карта е валиден съгласно гореописания алгоритъм.
##Сигнатура:
```haskell
isValid :: Int -> Bool
```

##Примери:
```haskell
isValid 79927398713 -> True
isValid 79927398715 -> False
```