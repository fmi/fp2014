##ИЗПИТ ПО ФУНКЦИОНАЛНО ПРОГРАМИРАНЕ
####Специалност “Компютърни науки”, 2-ри курс, 1-ви поток
####16.02.2015 г.

Решенията на задачите се предават по e-mail на адрес:

>fp2014.fmi@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.hs* или *.scm*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като *attachment-и* в *mail-a*. Освен решения на задачите самият *mail* трябва да съдържа име, административна група и факултен номер. 

##Задача 1 - k-divisors
Да се напише на езика `Scheme` функция `k-divisors`, която приема като аргументи две цели положителни числа - `N` и `k` и връща броя на целите числа между `1` и `N` включително, които имат точно `k` на брой различни прости делители (включвайки самото число).

###Сигнатура:
```scheme
(k-divisors n k)
```

###Примери:
```scheme
(k-divisors 6 2) 1
(k-divisors 6 3) 0
(k-divisors 16 2) 5
(k-divisors 246 3) 41
```

##Задача 2 - matrix sum
Да се напише на езика `Scheme` функция `matrix-sum`, която приема като аргумент квадратна матрица `NxN` и връща сумата на `N`-те числа X<sub>i</sub>, където за всяко `i` от `1` до `N`, `X`<sub>i</sub> е максималното измежду всички числа на `i`-тия ред и `i`-тата колона.
###Сигнатура:
```scheme
(matrix-sum matrix)
```
###Примери:
```scheme
(matrix-sum '((1 2 3) (4 5 6) (7 8 9))) 24
(matrix-sum '((7 4 2 0) (0 1 12 31) (0 9 1 0) (-3 7 -5 12))) 81
```

##Задача 3 - numbers
Да се напише на езика `Haskell` функция `numbers :: Int -> (Int -> [Int])`, която приема като аргумент цяло положително число `N` и връща функция на един аргумент `K`. При извикване на резултантната функция да се върне списък, който е получен, като от списъка с всички числа между `1` и `N` включително, които се делят на сумата от цифрите си, е премахнато всяко `K`-то число.
##Сигнатура:
```haskell
numbers :: Int -> (Int -> [Int])
```
##Примери:
```haskell
numbers 10  -- функция на един аргумент К, който е цяло число
numbers 10 2 = [1,3,5,7,9] -- всички числа между 1 и 10 се делят на сумата от --цифрите си, т.е., ако игнорираме подаденото К, ще получим списъка --[1,2,3,4,5,6,7,8,9,10]. Премахвайки всяко второ число от този списък, --получаваме горният резултат
numbers 23 3 = [1,2,4,5,7,8,10,12,20,21]
```

##Задача 4. - Search Tree
Нека е дефиниран следният тип, представящ двоично дърво:
```haskell
data Tree a = Empty | Node a (Tree a) (Tree a)
```
Да се напише на езика `Haskell` функция `isSearchTree :: (Ord a) => Tree a -> Bool`, която по зададено двоично дърво проверява дали за него е изпълнен инвариантът за дърво за търсене, т.е. стойността на всеки връх трябва да е по-голяма от стойностите на всички върхове в неговото ляво поддърво и по-малка от стойностите на всички върхове в дясното му поддърво.
При реализацията може свободно да се ползват вградените функции `max`, `min`, `maximum` и `minimum`.
##Сигнатура:
```haskell
isSearchTree :: (Ord a) => Tree a -> Bool
```
##Примери:
```haskell
searchTree = Node 5
		(Node 3
			(Node 1 Empty Empty)
			(Node 4 Empty Empty))
		(Node 11
			(Node 8 Empty Empty)
			Empty)
nonSearchTree = Node 5
			(Node 8 Empty Empty)
			(Node 22 Empty Empty)
isSearchTree searchTree = True
isSearchTree nonSearchTree = False
isSearchTree Empty = False
```