Домашна работа 10
=========

Решенията на задачите се предават по e-mail на адрес:

>fp2014.fmi@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.hs*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като *attachment-и* в *mail-a*. Освен решения на задачите самият *mail* трябва да съдържа име, група и факултен номер. Успех!

###Задача 1 - Conway's Game of life
[Conway’s Game of Life](http://en.wikipedia.org/wiki/Conway's_Game_of_Life) е симулация, която представя еволюционен процес върху `NxN` (игрова) дъска. На всяка позиция от дъската може или да има организъм (което ще означаваме със стойност `1` на този елемент от дъската), или съответно да няма такъв (означаваме с `0`). На всяка итерация от играта организмите върху дъската се променят (някои от тях умират, а други се размножават и на дъската се появяват нови) спрямо следните правила:
Всяка жива клетка с по-малко от `2` съседа умира на следващата итерация поради самота.
Всяка жива клетка с `2` или `3` съседа продължава да живее и през следващата итерация.
Всяка жива клетка с повече от `3` живи съседа умира на следващата итерация поради пренаселеност.
Всяка мъртва клетка с точно `3` живи съседа се ражда на следващата итерация поради размножаване.
Всяка клетка (с изключение на тези по крайщата на дъската) има по `8` съседа (съседите на клетката на позиция `(i, j)` са съответно `(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j+1), (i+1,j-1), (i+1, j), (i+1, j+1))`.

Да се напише функция `nextGeneration :: [[Int]] -> [[Int]]`, която получава като вход някакво състояние на играта - `NxN` матрица, съдържаща само `0` и `1` и извежда състоянието на играта през следващата итерация, прилагайки гореописаните правила.


**Сигнатура:**

```haskell
nextGeneration :: [[Int]] -> [[Int]]
```

**Примери:**

```haskell
nextGeneration [[0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [1, 0, 0, 1]] -> [[0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 0]]
nextGeneration [[1, 1, 1], [1, 1, 1], [1, 1, 1]] -> [[1, 0, 1], [0, 0, 0], [1, 0, 1]]
```

###Задача 2 - Tic-Tac-Toe
Да се напише функция `nextStates :: [[String]] -> String -> [[[String]]]`, която получава като аргументи `3х3` матрица, представяща текущото състояние на игра на морски шах иниз (`"X"` или `"O"`), който означава кой от двамата играчи е на ходв. Функцията да връща всички възможни нови състояния на играта след като въпросният играч направи ход.Състоянието на играта представяме като матрица, в която `"-"` означава празна клетка, а `"X"` и `"O"` означават съответно клетки заети от двамата играчи.

**Сигнатура:**

```haskell
nextStates :: [[String]] -> String -> [[String]]
```

**Примери:**

```haskell
nextStates [["-", "X", "O"], ["O", "X", "X"], ["O", "-", "O"]] "X" -> [[["X", "X", "O"], ["O", "X", "X"], ["O", "-", "O"]], [["-", "X", "O"], ["O", "X", "X"], ["O", "X", "O"]]]
nextStates [["O", "X", "O"], ["X", "X", "O"], ["X", "O", "O"]] -> []
```

###Задача 3 - intersection
Да се напише функция `intersection :: [a] -> [a] -> [a]`, която приема като аргументи `2` списъка и връща сечението им.


**Сигнатура:**

```haskell
intersection :: (Eq a) => [a] -> [a] -> [a]
```

**Примери:**

```haskell
intersection [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] -> [4, 5]
intersection [] [1, 2, 3] = []
intersection [1, 2, 3] [4, 5, 6] = []
```

###Задача 4 - difference
Да се напише функция `difference :: (Eq a) => [a] -> [a] -> [a]`, която приема като аргументи `2` списъка и връща тяхната разлика.

**Сигнатура:**

```haskell
difference :: (Eq a) => [a] -> [a] -> [a]
```

**Примери:**

```haskell
difference [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] -> [1, 2, 3]
difference [] [1, 2, 3] -> []
difference [1, 2, 3] [4, 5, 6] -> [1, 2, 3]
```
