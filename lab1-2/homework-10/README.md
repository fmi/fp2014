Домашна работа 10
=========

Решенията на задачите се предават по e-mail на адрес:

>fp2014.fmi@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.hs*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като *attachment-и* в *mail-a*. Освен решения на задачите самият *mail* трябва да съдържа име, група и факултен номер. Успех!

###Задача 1 - Tic-Tac-Toe - незадължителен за предаване БОНУС
Да се напише функция `nextStates :: [[String]] -> String -> [[[String]]]`, която получава като аргументи `3х3` матрица, представяща текущото състояние на игра на морски шах и низ (`"X"` или `"O"`), който означава кой от двамата играчи е на ход. Функцията да връща всички възможни нови състояния на играта след като въпросният играч направи ход.Състоянието на играта представяме като матрица, в която `"-"` означава празна клетка, а `"X"` и `"O"` означават съответно клетки заети от двамата играчи.

**Сигнатура:**

```haskell
nextStates :: [[String]] -> String -> [[String]]
```

**Примери:**

```haskell
nextStates [["-", "X", "O"], ["O", "X", "X"], ["O", "-", "O"]] "X" -- [[["X", "X", "O"], ["O", "X", "X"], ["O", "-", "O"]], [["-", "X", "O"], ["O", "X", "X"], ["O", "X", "O"]]]
nextStates [["O", "X", "O"], ["X", "X", "O"], ["X", "O", "O"]] -- []
```

**Hint**: един от възможните начини за решение на задачата е:
- дефинираме функция `positions :: [[String]] -> [(Int, Int)]`, която по зададено състояние на играта връща индексите на всички позиции, където може да се играе (тези означени с `"-"`)
- дефинираме функция `mapWithIndex :: (a->Int->b) -> [a] -> [b]`, която работи като стандартния `map`, но подава на функцията освен всеки елемент от списъка и неговия индекс
- дефинираме функция `mapRows board replaceRowIndex replaceColumnIndex`, в която прилагаме`mapWithIndex` върху `board` - функцията която се подава на `mapWithIndex` е `mapElement row elemRowIndex replaceRowIndex replaceColumnIndex`
- дефинираме функция `mapElement row elemRowIndex replaceRowIndex replaceColumnIndex`, в която прилагаме `mapWithIndex` върху `row`, а функцията която се подава на `mapWithIndex` е `replaceElement elem elemColumnIndex elemRowIndex replaceRowIndex replaceColumnIndex`,
- дефинираме функция `replaceElement elem elemColumnIndex elemRowIndex replaceRowIndex replaceColumnIndex`, в която проверяваме дали `(elemColumnIndex == replaceColumnIndex) && (elemRowIndex == replaceRowIndex)`. Ако е така връщаме `player` (тъй като на тази позиция има "-"). В противен случай връщаме `elem` (елементът на тази позиция непроменен)
- дефинираме `nextStates` като прилагаме `map` върху резултата от извикването на `positions`, а като функция подаваме `mapRows`

###Задача 2 - intersection
Да се напише функция `intersection :: [a] -> [a] -> [a]`, която приема като аргументи `2` списъка и връща сечението им.


**Сигнатура:**

```haskell
intersection :: (Eq a) => [a] -> [a] -> [a]
```

**Примери:**

```haskell
intersection [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] -- [4, 5]
intersection [] [1, 2, 3] -- []
intersection [1, 2, 3] [4, 5, 6] -- []
```

###Задача 3 - difference
Да се напише функция `difference :: (Eq a) => [a] -> [a] -> [a]`, която приема като аргументи `2` списъка и връща тяхната разлика.

**Сигнатура:**

```haskell
difference :: (Eq a) => [a] -> [a] -> [a]
```

**Примери:**

```haskell
difference [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] -- [1, 2, 3]
difference [] [1, 2, 3] -- []
difference [1, 2, 3] [4, 5, 6] -- [1, 2, 3]
```
