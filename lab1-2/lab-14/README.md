Упражнение 14
=========

###Разгледани теми
- алгебрични типове данни

###Препоръчани материали
- [Declaring Types and Classes - TU-Delft, Part 1](http://delftxdownloads.tudelft.nl/FP101x-FunctionalProgramming/Week5/FP101x-chapter9-part1-video.720.mp4)
- [Declaring Types and Classes - TU-Delft, Part 2](http://delftxdownloads.tudelft.nl/FP101x-FunctionalProgramming/Week5/FP101x-chapter9-part2-video.720.mp4)
- [Declaring Types and Classes - TU-Delft, Part 3](http://delftxdownloads.tudelft.nl/FP101x-FunctionalProgramming/Week5/FP101x-chapter9-part3-video.720.mp4)
- [Functional Programming - 101, TU-Delft](https://github.com/fptudelft/FP101x-Content)

###Задачи
- да се дефинира тип `Vector2d`, чийто value конструктор приема 2 реални аргумент - х и у координатите на вектора
- да се дефинира функция `vectorLength :: Vector2d -> Float`, която връща дължината на даден вектор (`sqrt x^2 + y^2`)
- да се дефинира функция `addVectors :: Vector2d -> Vector2d -> Vector2d`, която събира 2 вектора
- да се дефинира функция `dotProduct :: Vector2d -> Vector2d -> Float`, която намира скаларното произведение на 2 вектора
- да се направи `Vector2d` подтип на `Eq` и `Show`
- да се дефинира тип `Shape`, който има 2 value конструктора - `Shape` и `Circle`
- да се дефинира функция `area :: Shape -> Float`, която намира лицето на дадена фигура
- да се дефинира функция `isRect :: Shape -> Bool`, която връща дали дадена фигура е правоъгълник
- да се направи `Shape` подтип на `Eq` и `Show`
- да се дефинира тип `Tree`, представящ двоично дърво
- да се дефинира функция `treeHeight :: Tree a -> Int`, която връща височината на дърво
- да се дефинира функция `isBalanced :: Tree a -> Bool`, която проверява дали едно дърво е балансирано (дали е празно или разликата във височините на лявото и дясно поддървета е най-много 1)
- да се дефинира функция `member :: a -> Tree a -> Bool`, която проверява дали даден елемент се съдържа в двоично дърво
- да се дефинира функция `member' :: a -> Tree a -> Bool`, която проверява дали даден елемент се съдържа в двоично дърво за търсене
- да се дефинира функция `inOrder :: Tree a -> [a]`, която записва в списък стойностите на елементите на дърво, обходени в реда ляво-корен-дясно
- да се дефинира функция `preOrder :: Tree a -> [a]`, която записва в списък стойностите на елементите на дърво, обходени в реда корен-ляво-дясно
- да се дефинира функция `postOrder :: Tree a -> [a]`, която записва в списък стойностите на елементите на дърво, обходени в реда ляво-дясно-корен
- да се дефинира функция `insert :: (Ord a) => a -> Tree a -> Tree a`, която вмъква елемент в двоично дърво за търсене
- да се дефинира функция `level :: Int -> Tree a -> [a]`, която връща списък с всички елементи на двоично дърво, които се намират на дълбочина `k`
- да се дефинира функция `sumTree :: Tree Int -> Int`, която сумира стойностите на всички елементи на двоично дърво от цели числа
- да се дефинира функция `minTree :: (Ord a) => Tree a -> a`, която намира минималният елемент в двоично дърво
- да се направи `Tree` подтип на `Show` и `Eq`
