Упражнение 10
=========

###Разгледани теми
- tuples, type synonyms, function composition, function identity

###Задачи
- да се напише функция `fst' :: (a, b, c) -> a`, която извлича първият елемент от наредена тройка
- да се напише функция `snd' :: (a, b, c) -> b`, която извлича вторият елемент от наредена тройка
- да се напише функция `third' :: (a, b, c) -> c`, която извлича третият елемент от наредена тройка
- да се напише функция `zip' :: [a] -> [b] -> [(a, b)]`, която приема като аргументи 2 списъка и връща като резултат нов списък от наредени двойки, в който всяка двойка се състои от i-тите елементи на двата списъка
- да се напише функция `zipWith' ::(a -> b -> c) -> [a] -> [b] -> [c]`, която приема като аргументи функция на 2 аргумента и 2 списъка и връща като резултат нов списък, в който всеки елемент е получен като към i-тите елементи на двата списъка е била приложена подадената функция
- да се напише функция `findWhere :: (a -> Bool) -> [a] -> Maybe a`, която приема като аргумент предикат и списък и връща първият елемент в списъка, който отговаря на предиката или Nothing, ако такъв елемент няма
- да се напише функция `getName :: Contact -> String`, която извлича името на контакт в телефонен указател представен като наредена двойка `(name, phone)`
- да се напише функция `getNumber :: Contact -> String`, която извлича номера на контакт в телефонен указател представен като наредена двойка `(name, phone)`
- да се напише функция `addContact :: PhoneBook -> Contact -> PhoneBook`, която добавя контакт в телефонен указател
- да се напише функция `findContact :: PhoneBook -> String -> Maybe Contact`, която намира контакт в телефонен указател по зададено име
- да се напише функция `removeContact :: PhoneBook -> String -> PhoneBook`, която изтрива контакт от телефонен указател по зададено име
- да се напише функция `hasContact :: PhoneBook -> String -> Bool`, която проверява дали дадено име се съдържа в телефонен указател като не се отчита case-sensitivity
- да се напише функция `compose :: (a -> b) -> (c -> a)` -> (c -> b), която приема като аргумент 2 функции и връща нова функция - тяхната композиция
- да се напише функция `twice :: (a -> a) -> (a -> a)`, която прилага двукратно подадената й като аргумент функция
- да се напише функция `negate :: (a -> Bool) -> (a -> Bool)`, която получава като аргумент предикат и връща неговото отрицание
- да се напише функция `flip' :: (a -> b -> c) -> (b -> a -> c)`, която получава като аргумент функция и връща нова функция с разменени аргументи
- да се напише функция `reject :: (a -> Bool) -> [a] -> [a]`, която получава като аргументи предикат и списък и връща нов списък, който съдържа всички елементи на изходния без тези, който отговарят на предиката
- да се напише функция `qsort :: (Ord a) => [a] -> [a]`, която сортира списък по метода на Hoare
- да се напише функция `reverseSort :: (Ord a) => [a] -> [a]`, която сортира списък в низходящ ред чрез бързо сортиране
- да се напише функция `tupleSort :: (Ord a) => [(a, b)] -> [(a, b)]`, която сортира списък от наредени двойки по първият елемент на двойката. Да се приложи за телефонния указател.
- да се напише функция `occurrences :: [a] -> [(a, Int)]`, която получава като аргумент списък и връща списък от наредени двойки, в който първи елемент на всяка двойка е някой от уникалните елементи в списъка, а втори елемент е броят на срещанията на този елемент. Може да се ползва наготова функцията `nub` от `Data.List`модула за премахване на повторенията в списък.
- да се напише функция `rotate :: [a] -> Int -> [a]`, която обръща списък n пъти (cycle от контролното)
- да се напише функция `fib :: Int -> Int -> [Int]`, която връща безкраен списък от числа на Фибоначи
