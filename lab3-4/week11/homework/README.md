Домашна работа 9
=========

Решенията на задачите се предават по e-mail на адрес:

>fp2014.fmi@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.hs*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като *attachment-и* в *mail-a*. Освен решения на задачите самият *mail* трябва да съдържа име, група и факултен номер. Успех!

Тъй като са празници, силно препоръчваме да решите и двете домашни на всички групи:

## Домашно на 1ва и 2ра група

[Домашното на 1ва и 2ра група](https://github.com/fmi/fp2014/tree/master/lab1-2/homework-9)

## Домашно на 3та и 4та група

### Задача 1

Отворете файла `matrix.hs` и имплементирайте написаните в него функции.

### Задача 2

Потоците в Haskell може да бъдат представени като безкрайни списъци.
Следният код генерира безкраен поток от просите числа:

```Haskell
primes :: [Int]
primes = filter isPrime [1..]
  where
    divisors n = [x | x <- [1..n], n `mod` x == 0]
    sumOfDivisors n = sum $ divisors n
    isPrime n = (n + 1) == sumOfDivisors n
```

Като го използваме по следният начин:

```Haskell
take 10 primes -- [2,3,5,7,11,13,17,19,23,29]
```

Безкраен списък може да създадем и с безкрайна рекурсия, която строи списъци.

Например, имплементацията на `repeat` изглежда така:

```haskell
repeat' x = x : repeat' x
```

Ако искаме първите 5 елемента, трябва да ги поискаме с `take`:

```haskell
take 5 $ repeat 1
[1, 1, 1, 1, 1]
```

Това работи поради следната причина. Нека първо да видим дефиницията на `take`:

```haskell
take _ [] = []
take 0 _ = []
take n (x:xs) = x : take (n - 1) xs
```

Тогава изразът `take 5 $ repeat 1` се оценява до:

```haskell
take 5 $ repeat 1 =  1 : take 4 $ repeat 1 = 1 : 1 : take 3 $ repeat 1 = 1 : 1 : 1 : take 2 $ repeat 1 = 1 : 1 : 1 : 1 : take 1 $ repeat 1 = 1 : 1 : 1 : 1 : 1 : take 0 $ repeat 1 = 1 : 1 : 1 : 1 : 1 : [] = [1, 1, 1, 1, 0]
```

Haskell никога не пресмята целият израз на `repeat 1` а взима само поредната глава от безкрайния списък.

Отворете файла `streams.hs` и имплементирайте функциите, които са описани вътре :)

### Задача 3

Напишете функцията `split`, която има следната сигнатура:

```haskell
split :: String -> String -> [String]
```

* Първият аргумент е `delimiter`
* Вторият е някакъв низ
* функцията връща списък от всички части, след като разделим низа по `delimiter`

Примеи:

```haskell
> split " " "Hello friend! How is your Haskell?"
["Hello", "friend!", "How", "is", "your", "Haskell?"]
> split "" "How should i split on empty string?"
["How should i split on empty string?"]
```
