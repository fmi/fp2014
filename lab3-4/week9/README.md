# Второ упражнение по Haskell

Нещата за които си говорихме:

* Кошници, Типове и Типови класове
* Списъци, функции за списъци и работа със списъци в Haskell
* Някой функции от по-висок ред като `map`, `filter`, `all`, `any`


## Кошници, Типове и Типови класове

Тази тема в книгата - http://learnyouahaskell.com/types-and-typeclasses

Haskell е статично типизиран език и всяка функция си има своята сигнатура.

Нека да имаме следната функция:

```haskell
add :: Int -> Int -> Int
add a b = a + b
```

Ако извикаме тази функция с две цели числа, тя ще работи:

```haskell
> add 1 2
3
```

Обаче ако извикаме функцията с `Double` числа, ще получим грешка:

```haskell
> add 1.0 2.0
<interactive>:4:5:
    No instance for (Fractional Int) arising from the literal `1.0'
    Possible fix: add an instance declaration for (Fractional Int)
    In the first argument of `add', namely `1.0'
    In the expression: add 1.0 2.0
    In an equation for `it': it = add 1.0 2.0
```

Какъв е проблемът? Би трябвало да може да съберем както две цели числа, така и две числа с плаваща запетая - не бива това да е проблем.

Проблемът идва от сигнатурата, която ние сами написахме: `add :: Int -> Int -> Int`

Чрез нея се ограничаваме сано с `Int` типове.

Ако махнем сигнатурата и напишем фунцкията само така:

```haskell
add a b = a + b
```

И тестваме в __ghci__:

```haskell
> add 1 2
3
> add 1.0 2.0
3.0
```

Функцията работи!

Haskell се е сетил, че тази функция може да има по-обща сигнатура, така че да нямаме проблем с `Int` и `Double`.

Но как може да разберем тази сигнатура? За щастие, в ghci, има командата `:t`, която ако дадем име на функция, ще върне сигнатурата, която:

* Ние сме написали
* Ако не сме написали сигнатура, ще ни даде сигнатурата, която Haskell сам се е сетил!

Нека да видим нашият `add` как изглежда:

```haskell
> :t add
add :: Num a => a -> a -> a
```

Уау! Нека да видим тази сигнатура отблизо:

```haskell
add :: Num a => a -> a -> a
```

В нея има две нови неща:

* `Num a =>`
* Самото `a`

Когато функцията ни може да работи с всякакъв тип, без да се интересуваме от неговата контретика, може да напишем `a` като име на този тип.

Например, функцията, която намира дължина на списък има следната сигнатура:

```haskell
length :: [a] -> Int
```

Функцията се чете така: __"Length е функция, която приема списък от нещо и връща цяло число".__

Това ни позволява да намерим дължина на списък, без да се интересуваме от какви елементи е съставен този списък!

Ако обаче имаме `Num a =>` в сигнатурата, това означава, че нашият тип `a`, какъвто и да е той, трябва да приднадлежи на типовия клас `Num`.

Тук казваме, че типът трябва да е в кошницата на `Num`.

`Num` е кошница, в която се намират типове като `Int` и `Double` и тази кошница, действа като интерфейс.

Типовете, които се намират в нея, трябва да имплементират функцията `(+)` между две инстанции от дадения тип.

Самият типов клас `Num`, изглежда така в кода на Haskell: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Num.html#Num
