# Ретроспекция на всичко до сега.

## Обобщение

Ще обобщим всичко, което сме учили и ще рашаваме задачи, преди да преминем напред с материала.

__1. Функции и рекурсия в Haskell:__

* Pattern matching
* Guards
* Работа със списъци / tuples

__2. Типове и типова система. Полиморфизъм в Haskell__

* `Int` vs. `[Int]` vs. `(Int)`
* Полиморфен тип `a`-> какво означава?
* Типова дефиниция на функция и :t командата в ghci
* Типови класове - интуиция за тях.

__3. Защо имаме типове и как това се връзва с композиране на функции? (Типове = композируемост):__

* Каква е дефиницията на (.) ?
* Една Haskell-ска програма представлява композиране на поредица от функции

__4. Функции от по-висок ред:__

* Вградените map / filter / foldl / foldr / any / all / takeWhile / dropWhile
* Ламбда функция - синтаксис и употреба
* Частично приложени функции `(*2)` `(==2)` какво означават?
* Какво означава currying в Haskell и какво ни дава това?

## Задачи

В Haskell има вградена функция `gcd`, която намира [greatest commen divisor](http://en.wikipedia.org/wiki/Greatest_common_divisor)


### Coprime integers

Напишете функция `coprime :: Int -> Int ->`Bool`, която връща истина, ако две числа са coprime.

Две числа (integers) са coprime, ако тяхното `gcd` е равно на 1.

__Например:__

```haskell
coprime 9 28 == True
coprime 7 21 == False
```

### Euler's Totient Function

Напишете функция `totient :: Int -> Int`, която имплементира Ойлеровата Фи функция, която е описана тук - http://en.wikipedia.org/wiki/Euler%27s_totient_function

Тази функция (на един аргумент, нека да се казва `n`) дава броят на всички цели числа, по-малки или равни на аргумента си (`n`), които са __corpime с `n`__


__Например:__

```haskell
totient 9 == 6
totient totient 900000 == 240000
```

Тази функция се използва в [RSA алгоритъма](http://en.wikipedia.org/wiki/RSA_%28cryptosystem%29) за критиране, който се среща в HTTPS връзките в уеба.

### Zero-Insert

Напишете функция `zeroInsert :: Int -> Int`, която получава като аргумент цяло число и връща ново число получено по следния начин:
    * ако две съседни цифри във входното число са еднакви, то да се запишат на съответните позиции в изходното с `0` между тях
    * ако сумата на две съседни цифри дава остатък `0` при деление на `10`, то да се запишат в изходното число с `0` между тях
    * във всички останали случаи цифрите от входното число да се записват в изходното непроменени

__Например:__

```haskell
zeroInsert 116457 -> 10160457
zeroInsert 777777 -> 70707070707
zeroInsert 6446 -> 6040406
zeroInsert 1234 -> 123
```

### Subsequence

Напишете функция `subsequence :: (Eq a) => [a] -> [a] -> Bool`, която приема като аргументи два списъка и връща дали първият списък е подпоследователност на втория (т.е. дали вторият съдържа всички елементи на първия в същия ред + евентуално други елементи между тях)

```haskell
subsequence [] [] -> True
subsequence [] [1, 2, 3] -> True
subsequence [1, 2, 3] [] -> False
subsequence [5, 1, 7] [3, 4, 5, 6, 0, 1, 7, 8, 9] -> True
subsequence [5, 1, 7] [3,4,5,7,0,1,8,9] -> False
```

### Increasing

Казваме, че една функция `f` е строго монотонно растяща в целочисления интервал [a, b], ако за всеки две целочислени стойности `x` и `y` в `[a,b]`, за които `x < y` е в сила, че `f(x) < f(y)`.

Да се дефинира функция `increasing :: (Int -> Int) -> Int -> Int -> Bool`, която получава като аргументи функция `f` и числата `a` и `b` и връща истина, ако функцията `f` е строго монотонно растяща в интервала `[a,b]` и лъжа иначе.

Може да се счита, че `a <= b`.

```haskell
increasing (\x -> x + 1) 1 100 -> True
increasing (\x -> 1 - x) 1 100 -> False
increasing (\x -> 1 - x) 100 100 -> True
increasing (\x -> 42) 1 100 -> False
```

### Spam and Eggs

This is a problem from the [Python 2012 course in FMI](http://2012.fmi.py-bg.net/).

You can see the original problem statement here - http://2012.fmi.py-bg.net/tasks/1

Implement a function, called `prepareMeal :: Int -> String` that takes an integer and returns a string, generated by the following algorithm:

__Еggs:__

If there is an integer `n`, such that `3^n` divides `number` and `n` is the largest possible,
the result should be a string, containing `n` times `spam`.

For example:

```haskell
prepareMeal 3
"spam"
prepareMeal 27
"spam spam spam"
prepareMeal 7
""
```

__Spam:__

If number is divisible by 5, add `and eggs` to the result.

For example:

```haskell
prepareMeal 5
"eggs"
prepareMeal 15
"spam and eggs"
prepareMeal 45
"spam spam and eggs"
```

__Notice that in the first case, there is no "and". In the rest - there is.__

#### Test examples

```
prepareMeal 5 == "eggs"
prepareMeal 3 == "spam"
prepareMeal 27 == "spam spam spam"
prepareMeal 15 == "spam and eggs"
prepareMeal 45 == "spam spam and eggs"
prepareMeal 7 == ""
```

### Replace number

Напишете функция `replace :: Int -> [(Int, Int)] -> Int`, която приема като първи аргумент цяло число, а като втори списък от наредени двойки от цифри и връща числото, подадено като първи аргумент след като всяко срещане на цифра, която е на първо място в наредена двойка е било заменено от цифрата, която е на втора позиция в наредената двойка.

```haskell
replace 1278235341 [(1, 3), (7, 4), (5, 2)] -> 3248232343
```

### Set operations

- Да се напише функция `intersection :: (Eq a) => [a] -> [a] -> [a]`, която получава като аргументи два списъка и връща списък, който представлява тяхното сечение.
- Да се напише функция `union :: (Eq a) => [a] -> [a] -> [a]`, която получава като аргументи два списъка и връща списък, който представлява тяхното обединение. В резултата да не се допускат повторения на елементи.
- Да се напише функция `difference :: (Eq a) => [a] -> [a] -> [a]`, която получава като аргументи два списъка и връща списък, който представлява тяхната разлика.
- Да се напише функция `uniq :: (Eq a) => [a] -> [a]`, която приема списък и връща като резултат входния списък след като от него са премахнати всички повторения.

### Prime Factorization

Напишете фунцкия `primeFactorization :: Int -> [(Int, Int)]`, която взима цяло число и връща списък от tuples, който представлява разлагането на прости множители.

__Първият елемент на tuple-a е просто число, а вторият - съответната степен, на която трябва да се вдигне.__

Всяко цяло число `n` може да бъде предсатвено като произведение на прости числа, вдигнати на съответната степен. Като това представяне е уникално за числото.

Общият вид изглежда така:

```
n = p1^a1 * p2^a2 * p3^a3  * ... * pn^an
```

Нека разгледаме следните примери:

```
10 = 2^1 * 5^1
25 = 5^2
356 = 2^2 * 89 ^ 1
```

__Примери:__

```haskell
primeFactorization 10 == [(2, 1), (5, 1)]
primeFactorization 25 == [(5, 2)]
primeFactorization 356 == [(2, 2), (89, 1)]
```
